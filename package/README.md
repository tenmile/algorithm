背包问题相关算法
参考资料，背包九讲-2.0

01背包问题（每个物品都有放或者不放的可能性，故叫01背包问题）
	有N件物品和一个容量为V的背包。放入第i件物品耗费的空间是Ci，
得到的价值是Wi。求将哪些物品放入背包可使价值总和最大。
	用子问题定义状态：即F[i,v]表示前i件物品恰好放入一个容量为v
的背包可以获得的最大价值。其状态转移方程便是：
	F[i,v] = max{F[i-1,v], F[i-1,v-Ci]+Wi}（第i件物品放或者不放）
时间与空间复杂度都是O(VN)，由于i只与i-1有关，故可将空间优化到O(V)
注意要倒着计算，因为i和i-1的状态共用一个数组，注意计算顺序，不然
要用的旧数据会被生成的新数据覆盖。

	有两种问法，一种是恰好装满，另一种不是恰好装满，两种的区别
在于初始化数组的不同。可以这样理解：初始化的F数组事实上就是没有任何
物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量
为0的背包可以在什么也不装且价值为0的情况下被“恰好装满”，其它容量的
背包并没有合法的解，属于未定义的状态，应该被赋值为负无穷了。如果背包并非
必须被装满，那么任何背包都有一个合法的解“什么都不装”，这个解的价值为0。
	恰好装满，F[0]初始化为0，其它初始化为负无穷；不用恰好装满，都初始化为0。
	有个常数项的优化for v = V to max{V-sum(i,n,Ci), Ci}
	
完全背包问题
	与0,1背包问题不同的是，每个物品可以可以无限件使用。
	每件物品可以取1到V/Ci件
	F[i, v] = max{F[i-1,v-kCi]+kWi} (0<=kCi<=V)
	复杂度（NVsum(V/Ci)）
	一个简单的优化，若两件物品i，j满足Ci<=Cj且Wi>=Wj，则将物品j去掉，不用考虑，
（不一定？）万一需要恰好满足呢？
	将物品转化为1到V/Ci个物品是不高效的，有更高效的转化方法，把第i种物品拆成费用
为Ci2^k、价值为Wi2^k的若干件物品，其中k取遍Ci2^k<=V的非负整数。
	从而转化成01背包问题
	一个数总可以表示成若干个2^k，且保证每个数只取一次（二进制位每个数只有01两种情况）
	
多重背包问题
	每个物品限定Mi件物品可用
	
混合背包问题
	有的物品可以取一次，有的物品可以取Mi次，有的物品可以取无限次
	
	
	
	
二维费用的背包问题
	对于每件物品，具有两种不同的空间耗费，选择这件物品必须同时付出这两种代价
	第i件物品所需的两种代价分别为Ci和Di。两种代价可付出的最大值（两种背包容量）
分别为V和U。物品的价值为Wi。
	F[i,v,u] = max{F[i-1,v,u], F[i-1,v-Ci,u-Di]+Wi}
	
	
	
分组的背包问题
	物品被划分为K组，每组中的物品相互冲突，最多选一件。
	F[k,v] = max{F[k-1,v], F[k-1,v-Ci]+Wi|item i属于group k}
	分组将多一层循环，有两层循环变成三层循环
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	